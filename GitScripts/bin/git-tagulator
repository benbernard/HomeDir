#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

use Cwd ('abs_path');
use File::Basename;
use Getopt::Long;

# TODO: allow custom metadata per match (derived from filename, line number, or matched line) (where would this be stored?  in the DB?)
# TODO: allow match against custom metadata
# TODO: allow custom format for list (for extra metadata fields)

my $verbose = 0;
my $build = 1;
my $config_file;
my @prefilter;

my @options =
(
    "verbose!" => \$verbose,
    "build!" => \$build,
    "filter=s" => sub { push @prefilter, $_[1] },
    "config=s" => \$config_file,
    "help" => sub { usage(0); },
);
GetOptions(@options) || usage(1);

# STEP 0: find/read config
if(!defined($config_file))
{
    my $root = abs_path();
    while(1)
    {
        if(-d "$root/.git")
        {
            last;
        }
        if($root eq "/")
        {
            die "Cannot findup .git for repo root";
        }
        $root = dirname($root);
    }

    $config_file = "$root/.git/git-tagulator.cfg";
}

my $config = {};
{
    open(my $fh, "<", $config_file) || die "Cannot open $config_file: $!";

    while(my $l = <$fh>)
    {
        chomp $l;
        if($l =~ /^([^=]*)=(.*)$/)
        {
            $config->{$1} = $2;
        }
        else
        {
            die "Bad line in $config_file: $l";
        }
    }

    close($fh) || die "Cannot close $config_file: $!";
}

# everything is from root...
my $root = $config->{'root'} || die "No configured root?";
chdir($root) || die "Cannot chdir to $root: $!";

my $key_re = $config->{'key_regex'} || die "No configured key regex?";
my $accept_bin = $config->{'accept_bin'} || die "No configured accepting binary?";


print "Reading DB...\n" if($verbose);
# STEP 1: read DB
my $db_tree;
my %db_file_key_line_1;
my %db_key_file_line_1;
my %db_extrafile_1;
my $db_dirty = 0;
{
    my $fn = $config->{'db'};
    if(defined($fn) && -f $fn)
    {
        open(my $fh, '<', $fn) || die "Cannot open $fn: $!";
        while(my $l = <$fh>)
        {
            chomp $l;

            if(0)
            {
            }
            elsif($l =~ /^TREE:(.*)$/)
            {
                $db_tree = $1;
            }
            elsif($l =~ /^EXTRAFILE:(.*)$/)
            {
                my ($extrafile) = ($1);
                $db_extrafile_1{$extrafile} = 1;
            }
            elsif($l =~ /^MATCH:(.*):(.*):(.*)$/)
            {
                my ($file, $line, $key) = ($1, $2, $3);
                $db_file_key_line_1{$file}->{$key}->{$line} = 1;
                $db_key_file_line_1{$key}->{$file}->{$line} = 1;
            }
            else
            {
                die "Bad line: $l";
            }
        }
        close($fh) || die "Cannot close $fn: $!";
    }
}

# STEP 2: [re]build DB
if($build)
{
    print "Compiling delta and extra list...\n" if($verbose);
    # STEP 2a: compile delta and extra list
    my %extrafile_1;
    my %deltafile_1 = %db_extrafile_1;
    my @delta_cmds;

    # "extra" changes, always checked
    push @delta_cmds, [1, 'git', 'diff', 'HEAD', '--name-only', '--relative'];
    push @delta_cmds, [1, 'git', 'ls-files', '-o'];

    if(defined($db_tree))
    {
        # delta against old tree
        push @delta_cmds, [0, 'git', 'diff', $db_tree, 'HEAD', '--name-only', '--relative'];
    }
    else
    {
        # totally fresh list
        push @delta_cmds, [0, 'git', 'ls-files'];
    }

    for my $cmd (@delta_cmds)
    {
        my ($is_extra, @cmd) = @$cmd;
        print "Running " . join(" ", @cmd) . "...\n" if($verbose);
        open(my $fh, '-|', @cmd) || die "Cannot open exec " . join(" ", @cmd) . ": $!";
        my $re = $config->{'path_match'};
        while(my $l = <$fh>)
        {
            chomp($l);
            if(defined($re) && $l !~ $re)
            {
                next;
            }
            $deltafile_1{$l} = 1;
            if($is_extra)
            {
                $extrafile_1{$l} = 1;
            }
        }
        close($fh) || die "Cannot close exec " . join(" ", @cmd) . ": $!";
    }

    print "Rereading delta...\n" if($verbose);
    # STEP 2b: reread delta
    for my $deltafile (keys(%deltafile_1))
    {
        $db_dirty = 1;

        # STEB 2b1: delete the old
        my $key_line_1 = ((delete $db_file_key_line_1{$deltafile}) || {});
        for my $key (keys(%$key_line_1))
        {
            for my $line (keys(%{$key_line_1->{$key}}))
            {
                delete $db_key_file_line_1{$key}->{$deltafile}->{$line};
            }
        }

        # STEB 2b2: add the new
        if(-f $deltafile)
        {
            open(my $fh, "<", $deltafile) || die "Cannot open $deltafile: $!";
            my $n = 1;
            while(my $l = <$fh>)
            {
                if($l =~ $key_re)
                {
                    my $key = $1;
                    $db_file_key_line_1{$deltafile}->{$key}->{$n} = 1;
                    $db_key_file_line_1{$key}->{$deltafile}->{$n} = 1;
                }
                ++$n;
            }
        }
    }

    print "Renormalizing DB...\n" if($verbose);
    # STEP 2c: renormalize db
    my $db2_tree;
    my %db2_file_key_line_1;
    my %db2_key_file_line_1;
    my %db2_extrafile_1;
    {
        open(my $fh, '-|', 'git', 'log', '-1', '--format=%H') || die "Cannot open exec git log ...: $!";
        my $l = <$fh>;
        chomp $l;
        if($l =~ /^([0-9a-f]{40})$/)
        {
            $db2_tree = $1;
        }
        else
        {
            die "Bad show-ref HEAD: $l";
        }
        close($fh) || die "Cannot close exec git show-ref HEAD: $!";

        for my $file (keys(%db_file_key_line_1))
        {
            for my $key (keys(%{$db_file_key_line_1{$file}}))
            {
                for my $line (keys(%{$db_file_key_line_1{$file}->{$key}}))
                {
                    $db2_file_key_line_1{$file}->{$key}->{$line} = 1;
                }
            }
        }

        for my $key (keys(%db_key_file_line_1))
        {
            for my $file (keys(%{$db_key_file_line_1{$key}}))
            {
                for my $line (keys(%{$db_key_file_line_1{$key}->{$file}}))
                {
                    $db2_key_file_line_1{$key}->{$file}->{$line} = 1;
                }
            }
        }

        %db2_extrafile_1 = %extrafile_1;
    }

    # STEP 2d: commit DB
    $db_tree = $db2_tree;
    %db_file_key_line_1 = %db2_file_key_line_1;
    %db_key_file_line_1 = %db2_key_file_line_1;
    %db_extrafile_1 = %db2_extrafile_1;
}

# STEP 3: write DB
{
    my $fn = $config->{'db'};
    if($db_dirty && defined($fn))
    {
        print "Writing DB...\n" if($verbose);
        my $tmp = "$fn.tmp.$$";
        open(my $fh, '>', $tmp) || die "Cannot open $tmp: $!";
        print $fh "TREE:$db_tree\n";
        for my $extrafile (keys(%db_extrafile_1))
        {
            print $fh "EXTRAFILE:$extrafile\n";
        }
        for my $file (sort(keys(%db_file_key_line_1)))
        {
            for my $key (sort(keys(%{$db_file_key_line_1{$file}})))
            {
                for my $line (sort { $a <=> $b } (keys(%{$db_file_key_line_1{$file}->{$key}})))
                {
                    print $fh "MATCH:$file:$line:$key\n";
                }
            }
        }
        close($fh) || die "Cannot close $tmp: $!";
        (system('mv', '-f', '--', $tmp, $fn) == 0) || die "Cannot overwrite $fn with $tmp";
    }
}

my $options = [];
for my $key (sort(keys(%db_key_file_line_1)))
{
    for my $file (sort(keys(%{$db_key_file_line_1{$key}})))
    {
        for my $line (sort { $a <=> $b } (keys(%{$db_key_file_line_1{$key}->{$file}})))
        {
            push @$options, [$key, $file, $line];
        }
    }
}

my $force_display = 0;
while(1)
{
    if(@$options == 1)
    {
        my ($key, $file, $line) = @{$options->[0]};
        print "Accept $key at $file:$line\n" if($verbose);
        exec($accept_bin, $file, $line);
    }
    elsif($force_display || (@$options < ($config->{'limit'} || 30)))
    {
        print scalar(@$options) . " options:\n";
        for(my $i = 0; $i < @$options; ++$i)
        {
            my ($key, $file, $line) = @{$options->[$i]};

            print "" . ($i + 1) . ") $key at $file:$line\n";
        }
    }
    else
    {
        print scalar(@$options) . " options (too many).\n";
    }

    my $l;
    if(@prefilter)
    {
        $l = shift @prefilter;
        print "> $l\n";
    }
    else
    {
        print "> ";
        $l = <>;
    }

    if(!defined($l))
    {
        print "Bail.\n";
        exit 0;
    }

    chomp $l;

    if($l eq '')
    {
        if(@$options)
        {
            $force_display = 1;
        }
        else
        {
            print "Bail.\n";
            exit 0;
        }
    }
    elsif($l =~ /^[0-9]*$/)
    {
        my $i = $l - 1;
        $options = [$options->[$i]];
    }
    elsif($l =~ /^\/(.*)\/(i?)$/)
    {
        my $s = $1;
        my $ic = $2;
        my $re = ($ic ne '') ? qr/$s/i : qr/$s/;

        my $options2 = [];
        for my $option (@$options)
        {
            if($option->[0] =~ $re)
            {
                push @$options2, $option;
            }
        }

        $options = $options2;
    }
    elsif($l =~ /^(([A-Z][a-z0-9_]*)|\*)*\$?$/)
    {
        my $re = $l;
        $re =~ s/\*/.*/g;
        $re =~ s/([A-Z][a-z0-9_]*)/${1}[0-9a-z_]*/g;
        $re = qr/^$re/;

        my $options2 = [];
        for my $option (@$options)
        {
            if($option->[0] =~ $re)
            {
                push @$options2, $option;
            }
        }

        $options = $options2;
    }
    else
    {
        die "WTF: $l";
    }
}

sub usage
{
    my $ec = shift;

    print <<EOF;
Usage: $0 <options>
    --[no]build                       Indicate whether or not to rebuild DB.
    --filter <filter>                 Prefilter results as if <filter> had been typed.
    --verbose                         Be verbose.
   --help                             Print this help.
EOF

    exit $ec;
}
