" Make ctrl-a search files
nnoremap <C-a> :Files<cr>
"autocmd VimEnter * nnoremap <C-a> :<C-u>Unite -buffer-name=files -prompt-direction=above -start-insert file_rec/async:!<cr>

" maiing for \ag
nnoremap <leader>ag :Ag <C-r><C-w><CR>

" set history directory into normal tmp dir
let g:fzf_history_dir = $HOME . "/.config/nvim/tmp"

" \ur to insert prequire statements
function! Insert_require(path)
  let line = system('relativePath.pl ' . a:path . ' 2>/dev/null')
  echom 'relativePath.pl ' . a:path . ' ' . expand('%:p') . ' 2>/dev/null'
  execute "normal! mqgg}O" . line . "\<esc>`q"
endfunction
command InsertRequire call fzf#run(fzf#wrap('requires', {'sink': function('Insert_require'), 'options': '-q ".js "'}))
map <Leader>ur :InsertRequire<CR>

" \ud to insert drequire statements
function! Insert_require_dynamic(path)
  let line = system('relativePath.pl --dynamic ' . a:path . ' 2>/dev/null')
  echom 'relativePath.pl --dynamic ' . a:path . ' ' . expand('%:p') . ' 2>/dev/null'
  execute "normal! mqgg}O" . line . "\<esc>`q"
endfunction
command InsertRequireDynamic call fzf#run(fzf#wrap('requires', {'sink': function('Insert_require_dynamic'), 'options': '-q ".js "'}))
map <Leader>ud :InsertRequireDynamic<CR>

" \it to insert import type statements
function! Insert_type(path)
  let line = system('createImportLine.sh ' . a:path . ' ' . expand('%p') . ' 1 2>/dev/null')
  echom 'createImportLine.sh ' . a:path . ' ' . expand('%p') . ' 1 2>/dev/null'
  execute "normal! mqG?import \<CR>o" . line . "\<esc>`q"
endfunction
command InsertTypeImport call fzf#run(fzf#wrap('imports', {'sink': function('Insert_type'), 'options': '-q "/generated__/ .graphql.js ' . expand('%:t:r') . ' "'}))
map <Leader>it :InsertTypeImport<CR>

" \if to insert import of files
function! Insert_import(path)
  let line = system('createImportLine.sh ' . a:path . ' ' . expand('%p') . ' 2>/dev/null')
  echom 'createImportLine.sh ' . a:path . ' ' . expand('%p') . ' 2>/dev/null'
  execute "normal! mqG?import \<CR>o" . line . "\<esc>`q"
endfunction
command InsertImport call fzf#run(fzf#wrap('imports', {'sink': function('Insert_import'), 'options': '-q "webpack/assets/javascripts/core "'}))
map <Leader>if :InsertImport<CR>

" \ig to search all import statements
function! Insert_generic_import(path)
  let import = substitute(a:path, '^.\{1,}:\d\+:', '', '\v')
  execute "normal! mqG?import \<CR>o" . import . "\<esc>`q"
endfunction
" command InsertGenericImport call fzf#run(fzf#wrap('imports', {'sink': function('Insert_generic_import'), 'options': '-q "webpack/assets/javascripts/core "'}))
command InsertGenericImport call fzf#run(fzf#wrap('imports', {
      \ 'sink': function('Insert_generic_import'),
      \ 'options': '-q "webpack/assets/javascripts/core "',
      \ 'source': printf('ag "^import" webpack')
      \ }))
map <Leader>ig :InsertGenericImport<CR>

command! -nargs=+ RgWithDirectory :call RgWithDirectory(<f-args>)

" \ul to search for the word under the cursor
map <Leader>ul :RgWithDirectory <C-R><C-W> .<CR>

" \ug to search to a prompted word
function PromptForSearch()
  call inputsave()
  let term = input('Search: ')
  call inputrestore()
  call RgWithDirectory(term, '.')
endfunction
map <Leader>ug :call PromptForSearch()<CR>

function! RgWithDirectory(query, dir)
  call fzf#vim#grep('rg --column --line-number --no-heading --color=always --smart-case '.shellescape(a:query), 1, fzf#vim#with_preview({'dir': a:dir}, 'right:50%'), 0)
endfunction

" Next two are variants on \ug and \ul that prompt for a directory to search
" inside of (\uL and \uG)
function PromptForSearchAndPath()
  call inputsave()
  let term = input('Search: ')
  call inputrestore()

  call inputsave()
  let dir = input('Directory: ')
  call inputrestore()

  call RgWithDirectory(term, dir)
endfunction
map <Leader>uG :call PromptForSearchAndPath()<CR>

function PromptForPath(term)
  call inputsave()
  let dir = input('Directory: ')
  call inputrestore()

  call RgWithDirectory(a:term, dir)
endfunction
map <Leader>uL :call PromptForPath('<C-R><C-W>')<CR>

" use \uh for help tags search
map <Leader>uh :Helptags<CR>

" use Ctrl-S to search through modified get files
map <C-s> :GFiles?<CR>

command! -nargs=+ -complete=dir AgIn call s:ag_in(<f-args>)
"   :Ag  - Start fzf with hidden preview window that can be enabled with "?" key
"   :Ag! - Start fzf in fullscreen and display the preview window above
command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview('up:60%')
  \                         : fzf#vim#with_preview('right:50%'),
  \                 <bang>0)

map <Leader>ub :Buffers<CR>

" Use \un to search for Neighboring files
function! s:fzf_neighbouring_files()
  let current_file =expand("%")
  let cwd = fnamemodify(current_file, ':p:h')
  let command = 'ag -g "" -f ' . cwd . ' --depth 0'

  call fzf#run({
        \ 'source': command,
        \ 'sink':   'e',
        \ 'options': '-m -x +s',
        \ 'window':  'enew' })
endfunction

command! FZFNeigh call s:fzf_neighbouring_files()
map <Leader>un :call FZFNeigh
